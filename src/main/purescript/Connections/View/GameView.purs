module Connections.View.GameView
  ( Event(..)
  , init
  , refreshEvery
  , State(..)
  , update
  , view
  ) where

import Connections.Api                           as Api
import Connections.Game                          as Game
import Data.Array                                as Array
import Data.Foldable                             as Foldable
import Data.Int                                  as Int
import Data.Maybe                                as Maybe
import Pux                                       as Pux
import Pux.Html                                  as H
import Pux.Html.Attributes                       as A
import Pux.Html.Events                           as E
import Signal.Time                               as Time

import Data.Maybe (Maybe(..))
import Data.Tuple (Tuple(..))
import Network.HTTP.Affjax (AJAX)
import Pux.Html (Html)
import Signal (Signal)

import Connections.Types
import Prelude

type State =
    { key         :: String     -- ^ Used to identify this game to the server.
    , isSpymaster :: Boolean    -- ^ Whether the UI should show spymaster view.
    , game        :: Maybe Game -- ^ The ongoing game, if any.
    }

data Event
    = EndTurn                -- ^ Tell server to end turn
    | Guess (Tuple Int Int)  -- ^ Tell server to guess a square
    | NewGame                -- ^ Tell server to generate a new game
    | GetStatus              -- ^ Fetch most recent game status. Update local state.

    -- Local only
    | ToggleSpymaster        -- ^ Change view of game. Local state only.

    -- Generated by other events
    | SideEffects            -- ^ The previous event had side-effects.
    | GotStatus (Maybe Game) -- ^ Fetched most recent game status. We should store it.

-- | Initial state of the UI.
init :: String -> State
init = { key: _, isSpymaster: false, game: Nothing }

-- | Handle events that can mutate the state, either locally or by talking to the
-- server. Pux.EffModel essentially encapsulates the new state and optional IO
-- actions that will cause future mutations (e.g. fetching data from the server).
update :: forall eff. Api.Client -> Event -> State -> Pux.EffModel State Event (ajax :: AJAX | eff)
-- TODO: Create a helper method for these mutation functions
update client EndTurn               state =
  let
    effect = map (handleMutableCall client state) (client.endTurn state.key)
  in
    Pux.onlyEffects state [effect]
update client (Guess coordinates)   state =
  let
    effect = map (handleMutableCall client state) (client.guess state.key coordinates)
  in
    Pux.onlyEffects state [effect]
update client NewGame               state =
  let
    effect = map (handleMutableCall client state) (client.newGame state.key)
  in
    Pux.onlyEffects state [effect]

update client GetStatus             state =
  let
    effect = do
        apiResponse <- client.status state.key

        case apiResponse of
            (Api.Results { results: maybeGame }) -> pure (GotStatus maybeGame)
            -- TODO: Log and dispaly to user
            (Api.Errors { errors: errors })      -> pure SideEffects
  in
    Pux.onlyEffects state [effect]

-- Changes local state only
update client ToggleSpymaster       state =
    Pux.noEffects (state { isSpymaster = not state.isSpymaster })

-- After making side-effects, update the status to show the side-effect
update client SideEffects           state = Pux.onlyEffects state [pure GetStatus]

update client (GotStatus maybeGame) state = Pux.noEffects (state { game = maybeGame })

handleMutableCall :: Api.Client -> State -> Api.Response Unit -> Event
handleMutableCall client state (Api.Results _) = SideEffects
-- TODO: Log and display to user
handleMutableCall client state (Api.Errors _)  = SideEffects

-- | View the entire UI, which spawns events on interaction from the user. 
view :: State -> Html Event
view { game, isSpymaster } =
  let
    gameStarted = Maybe.isJust game

    scoreView   = map viewScore game
    boardView   = map (viewGame isSpymaster) game
    buttonsView = viewButtons isSpymaster gameStarted
    title       = H.div [A.className "title"] [H.text "Connections"]

    components  = Array.catMaybes [Just title, scoreView, boardView, Just buttonsView]
  in
    H.div [A.className "app container-fluid"] components

-- | View score area, including status of the game and unguessed red/blue tiles 
viewScore :: Game -> Html Event
viewScore game@(Game { turn }) =
  let
    status :: Maybe Turn -> Turn -> String
    status (Just BlueTurn) _        = "Blue wins!"
    status (Just RedTurn)  _        = "Red wins!"
    status _               RedTurn  = "Red turn"
    status _               BlueTurn = "Blue turn"
  in
    H.div [A.className "score"] [
        -- Status message
        H.div [A.className "score-status"] [
            H.text (status (Game.winner game) turn)
        ],

        -- Display the score in form 'Red - Blue'
        H.div [A.className "score-numbers"] [
            H.span [A.className "score-red" ]     [H.text (show (Game.redRemaining game))],
            H.text " - ",
            H.span [A.className "score-blue"]     [H.text (show (Game.blueRemaining game))]
        ]
    ]

viewButtons :: Boolean -> Boolean -> Html Event
viewButtons isSpymaster gameStarted =
  let
    -- Some buttons are only present during the game
    endTurnButton =
        if gameStarted
        then [H.button [A.className "btn", E.onClick (const EndTurn)] [H.text "End Turn"]]
        else []

    toggleText =
        if isSpymaster
        then "Change to Player"
        else "Change to Spymaster"
    toggleSpymasterButton =
        H.div [] [
            H.button [A.className "btn", E.onClick (const ToggleSpymaster)] [
                 H.text toggleText
            ]
        ]
  in
    H.div [A.className "buttons"] (
        endTurnButton <> [
        H.button [A.className "btn", E.onClick (const NewGame)] [H.text "New Game"],
        toggleSpymasterButton
    ])

-- | HTML for the entire game board
viewGame :: Boolean -> Game -> Html Event
viewGame isSpymaster game@(Game { board: (Board board) }) =
  let
    isGameOver       = Maybe.isJust (Game.winner game)
    squareRowViews = Array.mapWithIndex (viewSquareRow isSpymaster isGameOver) board
  in
    H.div [A.className "board"] squareRowViews

-- | HTML for a row of squares
viewSquareRow :: Boolean -> Boolean -> Int -> Array Square -> Html Event
viewSquareRow isSpymaster isGameOver rowNum squares =
  let
    squareViews = Array.mapWithIndex (viewSquare isSpymaster isGameOver rowNum) squares
  in
    H.div [A.className "square-row row"] squareViews

-- | HTML for an individual square
viewSquare :: Boolean -> Boolean -> Int -> Int -> Square -> Html Event
viewSquare isSpymaster isGameOver rowNum colNum (Square { guessed, squareType, word }) =
  let
    guess   = Guess (Tuple rowNum colNum)

    -- Spymaster cannot click squares
    onClick =
        if isGameOver || guessed || isSpymaster
        then []
        else [E.onClick (const guess)]

    classes   = ["col-xs-1", "square", colorClass squareType isSpymaster guessed]
    className = Foldable.intercalate " " classes
  in
    H.div ([A.className className] <> onClick) [
        H.text word
    ]

-- | Class name for a square, given its type, whether it's guessed, and the
-- user's role
colorClass :: SquareType -> Boolean -> Boolean -> String
colorClass squareType isSpymaster isGuessed = case squareType of
    Red      | isGuessed   -> "square-red"
             | isSpymaster -> "square-red-unguessed"
    Blue     | isGuessed   -> "square-blue"
             | isSpymaster -> "square-blue-unguessed"
    Assassin | isGuessed   -> "square-assassin"
             | isSpymaster -> "square-assassin-unguessed"
    Grey     | isGuessed   -> "square-grey"
             | isSpymaster -> "square-grey-unguessed"
    _                      -> "square-blank"

-- | A signal to refresh the status on a regular basis (milliseconds)
refreshEvery :: Int -> Signal Event
refreshEvery frequencyMillis =
    map (const GetStatus) (Time.every (Int.toNumber frequencyMillis))
